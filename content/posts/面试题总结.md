+++
author = "yqg"
title = "前端面试题总结"
date = "2025-06-01"
description = ""
tags = [
    "面试",
]
+++

## CSS

### BFC

BFC 是块级格式化上下文，具有以下特点：

- 内部的 Box 垂直排列
- margin 会重叠
- 可以包含浮动元素
- 不会与浮动元素重叠

### 盒子模型

两种盒模型：

1. 标准盒模型：width = content
2. IE 盒模型：width = content + padding + border

### position 定位

五种定位方式：

- static：默认值
- relative：相对定位
- absolute：绝对定位
- fixed：固定定位
- sticky：粘性定位

### em、rem、px

- px：固定像素单位
- em：相对父元素字体大小
- rem：相对根元素字体大小

### 基线

- 文字排版的基准线
- vertical-align 属性
- 用于文本对齐

## JavaScript

### 原型与原型链

#### 1. 基本概念

```javascript
// 构造函数
function Person(name) {
  this.name = name;
}

// 实例对象
const person = new Person("张三");

// 原型关系
console.log(person.__proto__ === Person.prototype); // true
console.log(Person.prototype.constructor === Person); // true
console.log(Person.prototype.__proto__ === Object.prototype); // true
```

#### 2. 原型链查找机制

- 当访问对象属性时，会按照以下顺序查找：
  1. 对象自身属性
  2. 对象原型（`__proto__`）
  3. 原型链上的其他原型
  4. 直到找到 `Object.prototype`（原型链终点）

#### 3. 重要特性

- 原型链继承
- 属性共享
- 构造函数与原型的关系
- `instanceof` 判断原理

### 事件循环机制

#### 1. 基本概念

```javascript
// 宏任务（MacroTask）
setTimeout(() => {
  console.log("宏任务1");
}, 0);

// 微任务（MicroTask）
Promise.resolve().then(() => {
  console.log("微任务1");
});

// 执行顺序：微任务 > 宏任务
```

#### 2. 执行顺序

1. 同步代码（主线程）
2. 微任务队列
   - Promise.then/catch/finally
   - process.nextTick
   - MutationObserver
3. 宏任务队列
   - setTimeout/setInterval
   - setImmediate
   - I/O
   - UI 渲染

#### 3. 特点

- 单线程执行
- 异步任务处理
- 任务优先级
- 事件循环过程

### async 与 defer、onLoad 与 DOMContentLoaded

#### 1. script 标签属性

```html
<!-- 普通加载 -->
<script src="normal.js"></script>

<!-- async 异步加载 -->
<script async src="async.js"></script>

<!-- defer 延迟加载 -->
<script defer src="defer.js"></script>
```

#### 2. 加载顺序对比

| 属性   | 执行时机                | 阻塞情况   | 适用场景        |
| ------ | ----------------------- | ---------- | --------------- |
| 无属性 | 立即执行                | 阻塞解析   | 依赖 DOM 的脚本 |
| async  | 下载完立即执行          | 不阻塞解析 | 独立脚本        |
| defer  | DOMContentLoaded 前执行 | 不阻塞解析 | 依赖其他脚本    |

#### 3. 事件触发时机

```javascript
// DOMContentLoaded：DOM 解析完成时触发
document.addEventListener("DOMContentLoaded", () => {
  console.log("DOM 解析完成");
});

// load：页面所有资源加载完成时触发
window.addEventListener("load", () => {
  console.log("页面加载完成");
});
```

#### 4. 执行顺序

1. DOM 解析
2. DOMContentLoaded 事件
3. 资源加载（图片、样式等）
4. load 事件

#### 5. 使用建议

- 关键脚本：使用 defer
- 独立脚本：使用 async
- 依赖 DOM：等待 DOMContentLoaded
- 依赖资源：等待 load

### 浏览器缓存

#### 强缓存

1. 强缓存不会向服务器发送请求，直接从缓存中读取资源。
2. 相关字段

- **Expires**：过期时间（HTTP/1.0）
  ```http
  Expires: Wed, 21 Oct 2023 07:28:00 GMT
  ```
- **Cache-Control**：缓存控制（HTTP/1.1）
  ```http
  Cache-Control: max-age=31536000
  ```
  - `max-age`：最大缓存时间
  - `no-cache`：需要验证
  - `no-store`：不缓存
  - `private`：仅浏览器缓存
  - `public`：允许中间代理缓存

3. 优先级

   Cache-Control > Expires

#### 协商缓存

1. 基本概念

协商缓存会向服务器发送请求，服务器判断资源是否可用。

2. 相关字段

- **Last-Modified/If-Modified-Since**：基于文件修改时间
  ```http
  Last-Modified: Wed, 21 Oct 2023 07:28:00 GMT
  If-Modified-Since: Wed, 21 Oct 2023 07:28:00 GMT
  ```
- **ETag/If-None-Match**：基于文件内容
  ```http
  ETag: "33a64df551425fcc55e4d42a148795d9f25f89d4"
  If-None-Match: "33a64df551425fcc55e4d42a148795d9f25f89d4"
  ```

3. 优先级

   ETag > Last-Modified

4. 缓存流程

- 浏览器发起请求
- 服务器返回资源，带缓存标识
- 浏览器缓存资源
- 再次请求时，携带缓存标识
- 服务器判断资源是否可用
- 返回 304 或新资源

5. Express 实现示例

```javascript
const express = require("express");
const crypto = require("crypto");
const fs = require("fs");
const path = require("path");

const app = express();

// 模拟数据
let data = {
  content: "Hello World",
  lastModified: new Date().toUTCString(),
};

// 计算 ETag
function calculateETag(content) {
  return crypto.createHash("md5").update(content).digest("hex");
}

// 使用 Last-Modified 的示例
app.get("/last-modified", (req, res) => {
  const ifModifiedSince = req.headers["if-modified-since"];

  if (ifModifiedSince && ifModifiedSince === data.lastModified) {
    // 资源未修改，返回 304
    res.status(304).end();
  } else {
    // 资源已修改，返回新数据
    res.setHeader("Last-Modified", data.lastModified);
    res.json(data);
  }
});

// 使用 ETag 的示例
app.get("/etag", (req, res) => {
  const ifNoneMatch = req.headers["if-none-match"];
  const etag = calculateETag(data.content);

  if (ifNoneMatch && ifNoneMatch === etag) {
    // 资源未修改，返回 304
    res.status(304).end();
  } else {
    // 资源已修改，返回新数据
    res.setHeader("ETag", etag);
    res.json(data);
  }
});

// 更新数据的接口
app.post("/update", (req, res) => {
  data = {
    content: "Updated Content",
    lastModified: new Date().toUTCString(),
  };
  res.json({ message: "Data updated" });
});

// 文件协商缓存示例
app.get("/file", (req, res) => {
  const filePath = path.join(__dirname, "example.txt");

  fs.stat(filePath, (err, stats) => {
    if (err) {
      return res.status(404).end();
    }

    const ifModifiedSince = req.headers["if-modified-since"];
    const ifNoneMatch = req.headers["if-none-match"];

    // 使用 Last-Modified
    if (
      ifModifiedSince &&
      new Date(ifModifiedSince).getTime() >= stats.mtime.getTime()
    ) {
      return res.status(304).end();
    }

    // 使用 ETag
    const etag = calculateETag(stats.size + stats.mtime.getTime().toString());
    if (ifNoneMatch && ifNoneMatch === etag) {
      return res.status(304).end();
    }

    // 设置缓存头
    res.setHeader("Last-Modified", stats.mtime.toUTCString());
    res.setHeader("ETag", etag);

    // 发送文件
    res.sendFile(filePath);
  });
});

app.listen(3000, () => {
  console.log("Server running on port 3000");
});
```

6. 测试方法

```bash
# 1. 首次请求
curl -i http://localhost:3000/etag

# 2. 使用上次返回的 ETag 再次请求
curl -i -H 'If-None-Match: "etag值"' http://localhost:3000/etag

# 3. 更新数据
curl -X POST http://localhost:3000/update

# 4. 再次请求（将返回新数据）
curl -i http://localhost:3000/etag
```

7. 实现要点

- 使用 `Last-Modified` 时，需要精确到秒级
- 使用 `ETag` 时，可以使用文件内容的哈希值
- 两种方式可以同时使用，提供双重验证
- 考虑使用缓存中间件（如 `express-etag`）
